{
    "path": "backend/misc.py",
    "model_usage_metrics": {
        "Duration": 16837123210,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "backend/test_misc.py",
    "existing_test_code": "",
    "original_code": "from __future__ import annotations\n\nimport base64\nimport mimetypes\nfrom datetime import datetime\nfrom typing import Any, Optional\n\nfrom charset_normalizer import from_bytes\nfrom fastapi import Request, UploadFile\nfrom fsspec.asyn import AsyncFileSystem  # type: ignore\n\nfrom const import Constants\nfrom errs import BadRequest\n\n\ndef parse_datetime(v: Any) -\u003e datetime | None:\n    if v is None:\n        return None\n    if isinstance(v, datetime):\n        return v\n    if isinstance(v, float):\n        return datetime.fromtimestamp(v)\n    if isinstance(v, int):\n        return datetime.fromtimestamp(float(v))\n    if isinstance(v, str):\n        return datetime.strptime(v, Constants.DATETIME_FORMAT)\n    raise BadRequest(f\"Invalid datetime value: {v}\")\n\n\ndef format_datetime(v: datetime) -\u003e str:\n    return None if v is None else v.strftime(Constants.DATETIME_FORMAT)\n\n\ndef guess_mime_type(p: str) -\u003e str:\n    r, _ = mimetypes.guess_type(p)\n    return r or \"application/octet-stream\"\n\n\ndef detect_encoding(file_bytes: bytes) -\u003e str:\n    \"\"\"\n    Detect the encoding of a given byte sequence using charset-normalizer.\n\n    :param file_bytes: The content of the file in bytes.\n    :return: Detected encoding as a string.\n    \"\"\"\n    result = from_bytes(file_bytes).best()\n    return result.encoding if result is not None else \"\"\n\n\nasync def read_file_text(fs: AsyncFileSystem, p: str, encoding: Optional[str] = \"utf-8\") -\u003e tuple[str, str]:\n    f_bytes = await read_file_bytes(fs, p)\n    if encoding is None:\n        encoding = detect_encoding(f_bytes)\n    return f_bytes.decode(encoding), encoding\n\n\nasync def write_file_text(fs: AsyncFileSystem, p: str, text: str, encoding: str = \"utf-8\"):\n    t_bytes = text.encode(encoding)\n    await write_file_bytes(fs, p, t_bytes)\n\n\nasync def read_file_bytes(fs: AsyncFileSystem, p: str) -\u003e bytes:\n    async with fs.open(p, mode=\"rb\") as f:\n        return await f.read()\n\n\nasync def write_file_bytes(fs: AsyncFileSystem, p: str, f_bytes: bytes):\n    async with fs.open(p, mode=\"wb\") as f:\n        await f.write(f_bytes)\n\n\nasync def transfer_file(\n    src_fs: AsyncFileSystem,\n    src_p: str,\n    dst_fs: AsyncFileSystem,\n    dst_p: str,\n    buf_size: int = 65536,\n) -\u003e tuple[int, bytes | None]:\n    if buf_size is None or buf_size \u003c= 2048:\n        buf_size = 2048\n\n    got = 0\n    head: bytes | None = None\n\n    async with src_fs.open(src_p, mode=\"rb\") as src_f:\n        async with dst_fs.open(dst_p, \"wb\") as dst_f:\n            while True:\n                chunk: bytes = await src_f.read(buf_size)\n                if not chunk:\n                    break\n\n                if head is None:\n                    head = chunk\n\n                await dst_f.write(chunk)\n                got += len(chunk)\n\n    return got, head\n\n\nasync def transfer_stream(\n    src: UploadFile, dst_fs: AsyncFileSystem, dst_p: str, buf_size: int = 65536\n) -\u003e tuple[int, bytes]:\n    if buf_size is None or buf_size \u003c= 2048:\n        buf_size = 2048\n\n    got = 0\n    head: bytes = b\"\"\n\n    async with dst_fs.open(dst_p, \"wb\") as dst_f:\n        while True:\n            chunk = await src.read(buf_size)  # Use the async read method\n            if not chunk:\n                break\n            if not head:\n                head = chunk\n\n            await dst_f.write(chunk)\n            got += len(chunk)\n\n    return got, head\n\n\ndef parse_data_url(data_url: str) -\u003e tuple[str, str, bytes]:\n    \"\"\"\n    Parse the Data URL and return the MIME type, encoding, and data.\n    :param data_url: The Data URL to parse.\n    :return: A tuple containing the MIME type, encoding, and decoded data as bytes.\n    \"\"\"\n    if not data_url.startswith(\"data:\"):\n        raise ValueError(f\"Invalid data URL: {data_url}\")\n\n    header, encoded_data = data_url.split(\",\", 1)\n    mime_type, encoding = header.split(\";\")[0][5:], header.split(\";\")[1]\n    if encoding != \"base64\":\n        raise ValueError(\"Only base64 encoding is supported\")\n\n    data = base64.b64decode(encoded_data)\n    return mime_type, encoding, data\n\n\ndef get_str_header(req: Request, name: str, devault: str) -\u003e str:\n    return req.headers.get(name) or devault\n\n\ndef get_int_header(req: Request, name: str, devault: int) -\u003e int:\n    s = req.headers.get(name)\n    return int(s) if s else devault\n\n\ndef get_bool_header(req: Request, name: str, devault: bool) -\u003e bool:\n    s = req.headers.get(name)\n    return s == \"true\" if s else devault\n\n\ndef get_client_ip(req: Request) -\u003e str:\n    h = req.headers\n\n    x_forwarded_for = h.get(\"x-forwarded-for\")\n    if x_forwarded_for:\n        return x_forwarded_for.split(\",\")[0].strip()\n\n    real_ip = req.headers.get(\"x-real-ip\")\n    if real_ip:\n        return real_ip\n    if req.client:\n        return req.client.host\n    return \"\"\n\n\ndef get_client_port(req: Request) -\u003e int:\n    x_forwarded_port = req.headers.get(\"f-forwarded-port\")\n    if x_forwarded_port:\n        return int(x_forwarded_port)\n    if req.client:\n        return req.client.port\n    return 0\n\n\ndef get_client_proto(req: Request) -\u003e str:\n    x_forwarded_proto = req.headers.get(\"x-forwarded-proto\")\n    if x_forwarded_proto:\n        return x_forwarded_proto\n    if req.client:\n        return req.url.scheme\n    return \"\"\n\n\ndef get_client_proxy_chain(req: Request) -\u003e list[str]:\n    x_forwarded_for = req.headers.get(\"x-forwarded-for\")\n    if x_forwarded_for:\n        return [ip.strip() for ip in x_forwarded_for.split(\",\")]\n    return []\n\n\ndef basename(p: str) -\u003e str:\n    p = normalize_path(p)\n    _, r = p.split(\"/\", 1)\n    return r\n\n\ndef normalize_path(p: str) -\u003e str:\n    if not p:\n        return p\n    p = p.lstrip(\"/\").rstrip(\"/\")\n\n    components: list[str] = []\n    for c in p.split(\"/\"):\n        if c in {\"\", \".\"}:\n            break\n        if c == \"..\":\n            c = c[:-1]\n        components.append(c)\n\n    return \"/\".join(components)\n",
    "test_code": "import pytest\nfrom datetime import datetime\nfrom backend.misc import (\n    parse_datetime,\n    format_datetime,\n    guess_mime_type,\n    detect_encoding,\n    read_file_text,\n    write_file_text,\n    transfer_file,\n    transfer_stream,\n    parse_data_url,\n    get_str_header,\n    get_int_header,\n    get_bool_header,\n    get_client_ip,\n    get_client_port,\n    get_client_proto,\n    get_client_proxy_chain,\n    basename,\n    normalize_path\n)\nfrom errs import BadRequest\n\n# Test cases for the functions in backend/misc.py\n\nclass TestMiscFunctions:\n\n    # Test parse_datetime with valid datetime string\n    def test_parse_datetime_valid_string(self):\n        \"\"\"Test parse_datetime with a valid datetime string.\"\"\"\n        result = parse_datetime(\"2023-10-01 12:00:00\")\n        assert result == datetime(2023, 10, 1, 12, 0)\n\n    # Test parse_datetime with valid float timestamp\n    def test_parse_datetime_valid_float(self):\n        \"\"\"Test parse_datetime with a valid float timestamp.\"\"\"\n        result = parse_datetime(1633072800.0)\n        assert result == datetime(2021, 10, 1, 0, 0)\n\n    # Test parse_datetime with valid int timestamp\n    def test_parse_datetime_valid_int(self):\n        \"\"\"Test parse_datetime with a valid int timestamp.\"\"\"\n        result = parse_datetime(1633072800)\n        assert result == datetime(2021, 10, 1, 0, 0)\n\n    # Test parse_datetime with None\n    def test_parse_datetime_none(self):\n        \"\"\"Test parse_datetime with None.\"\"\"\n        result = parse_datetime(None)\n        assert result is None\n\n    # Test parse_datetime with invalid string\n    def test_parse_datetime_invalid_string(self):\n        \"\"\"Test parse_datetime with an invalid datetime string.\"\"\"\n        with pytest.raises(BadRequest):\n            parse_datetime(\"invalid datetime\")\n\n    # Test format_datetime with valid datetime\n    def test_format_datetime_valid(self):\n        \"\"\"Test format_datetime with a valid datetime object.\"\"\"\n        dt = datetime(2023, 10, 1, 12, 0)\n        result = format_datetime(dt)\n        assert result == \"2023-10-01 12:00:00\"\n\n    # Test format_datetime with None\n    def test_format_datetime_none(self):\n        \"\"\"Test format_datetime with None.\"\"\"\n        result = format_datetime(None)\n        assert result is None\n\n    # Test guess_mime_type with known file extension\n    def test_guess_mime_type_known(self):\n        \"\"\"Test guess_mime_type with a known file extension.\"\"\"\n        result = guess_mime_type(\"example.txt\")\n        assert result == \"text/plain\"\n\n    # Test guess_mime_type with unknown file extension\n    def test_guess_mime_type_unknown(self):\n        \"\"\"Test guess_mime_type with an unknown file extension.\"\"\"\n        result = guess_mime_type(\"example.xyz\")\n        assert result == \"application/octet-stream\"\n\n    # Test detect_encoding with valid bytes\n    def test_detect_encoding_valid(self):\n        \"\"\"Test detect_encoding with valid byte content.\"\"\"\n        result = detect_encoding(b'This is a test.')\n        assert result == 'utf-8'\n\n    # Test parse_data_url with valid data URL\n    def test_parse_data_url_valid(self):\n        \"\"\"Test parse_data_url with a valid data URL.\"\"\"\n        result = parse_data_url(\"data:text/plain;base64,SGVsbG8sIFdvcmxkIQ==\")\n        assert result == (\"text/plain\", \"base64\", b\"Hello, World!\")\n\n    # Test parse_data_url with invalid data URL\n    def test_parse_data_url_invalid(self):\n        \"\"\"Test parse_data_url with an invalid data URL.\"\"\"\n        with pytest.raises(ValueError):\n            parse_data_url(\"invalid_data_url\")\n\n    # Test get_str_header with existing header\n    def test_get_str_header_existing(self):\n        \"\"\"Test get_str_header with an existing header.\"\"\"\n        class MockRequest:\n            headers = {\"X-Custom-Header\": \"value\"}\n\n        req = MockRequest()\n        result = get_str_header(req, \"X-Custom-Header\", \"default\")\n        assert result == \"value\"\n\n    # Test get_str_header with non-existing header\n    def test_get_str_header_non_existing(self):\n        \"\"\"Test get_str_header with a non-existing header.\"\"\"\n        class MockRequest:\n            headers = {}\n\n        req = MockRequest()\n        result = get_str_header(req, \"X-Custom-Header\", \"default\")\n        assert result == \"default\"\n\n    # Test get_int_header with existing header\n    def test_get_int_header_existing(self):\n        \"\"\"Test get_int_header with an existing header.\"\"\"\n        class MockRequest:\n            headers = {\"X-Custom-Int\": \"10\"}\n\n        req = MockRequest()\n        result = get_int_header(req, \"X-Custom-Int\", 0)\n        assert result == 10\n\n    # Test get_int_header with non-existing header\n    def test_get_int_header_non_existing(self):\n        \"\"\"Test get_int_header with a non-existing header.\"\"\"\n        class MockRequest:\n            headers = {}\n\n        req = MockRequest()\n        result = get_int_header(req, \"X-Custom-Int\", 5)\n        assert result == 5\n\n    # Test get_bool_header with existing header\n    def test_get_bool_header_existing_true(self):\n        \"\"\"Test get_bool_header with an existing header set to 'true'.\"\"\"\n        class MockRequest:\n            headers = {\"X-Custom-Bool\": \"true\"}\n\n        req = MockRequest()\n        result = get_bool_header(req, \"X-Custom-Bool\", False)\n        assert result is True\n\n    # Test get_bool_header with non-existing header\n    def test_get_bool_header_non_existing(self):\n        \"\"\"Test get_bool_header with a non-existing header.\"\"\"\n        class MockRequest:\n            headers = {}\n\n        req = MockRequest()\n        result = get_bool_header(req, \"X-Custom-Bool\", True)\n        assert result is True\n\n    # Test basename with valid path\n    def test_basename_valid(self):\n        \"\"\"Test basename with a valid path.\"\"\"\n        result = basename(\"/path/to/file.txt\")\n        assert result == \"to/file.txt\"\n\n    # Test normalize_path with valid path\n    def test_normalize_path_valid(self):\n        \"\"\"Test normalize_path with a valid path.\"\"\"\n        result = normalize_path(\"/path/to/../file.txt\")\n        assert result == \"path/to/file.txt\"\n\n    # Test normalize_path with empty path\n    def test_normalize_path_empty(self):\n        \"\"\"Test normalize_path with an empty path.\"\"\"\n        result = normalize_path(\"\")\n        assert result == \"\"\n",
    "amount_of_generated_test_cases": 20,
    "single_test_run_command": "pytest backend/test_misc.py"
}