{
    "path": "backend/api.py",
    "model_usage_metrics": {
        "Duration": 9465759308,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "backend/test_api.py",
    "existing_test_code": "",
    "original_code": "from datetime import datetime, timezone\nimport http\nimport os\nfrom logging import Logger\nfrom langchain_core.messages import AIMessageChunk\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse, StreamingResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\n\nfrom dotenv import load_dotenv\nfrom misc import format_datetime\nfrom errs import BaseError\nfrom log import get_logger\nfrom graph import super_graph\n\nload_dotenv(dotenv_path=os.path.join(os.getcwd(), \".env\"))\n\n\nclass LoggingMiddleware(BaseHTTPMiddleware):\n    logger: Logger = get_logger(\"api\")\n\n    async def dispatch(self, request, call_next):\n        self.logger.info(\"Request body: %s\", await request.body())\n        resp = await call_next(request)\n        return resp\n    \n\nfastapi_app = FastAPI(validate_responses=False)\nfastapi_app.add_middleware(LoggingMiddleware)\nfastapi_app.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"], \n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@fastapi_app.exception_handler(BaseError)\nasync def custom_exception_handler(request: Request, exc: BaseError):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            \"path\": request.url.path,\n            \"timestamp\": format_datetime(datetime.now(timezone.utc)),\n            \"status\": exc.status_code,\n            \"error\": http.HTTPStatus(exc.status_code).phrase,\n            \"code\": exc.code,\n            \"message\": exc.detail,\n            \"params\": [],\n        },\n    )\n\n\n@fastapi_app.exception_handler(500)\nasync def internal_exception_handler(request: Request, exc):\n    if isinstance(exc, BaseError):\n        return await custom_exception_handler(request, exc)\n    return JSONResponse(status_code=exc.status_code, content={\"detail\": exc.detail})\n\n \n\n\n####################################################################\nasync def answer_generator(question: str):\n    try:\n        question = question.strip()\n\n        async for messages in super_graph.astream(\n            {\n                \"messages\": [\n                    (\"user\", question)\n                ],\n            },\n            {\"recursion_limit\": 150},\n            stream_mode=\"messages\"\n        ):\n            \n            checkpoint_ns:str = messages[1][\"checkpoint_ns\"]\n            is_cared_checkpoints = checkpoint_ns.startswith(\"search:\") or checkpoint_ns.startswith(\"note_taker:\")\n            if True or is_cared_checkpoints:\n                for msg in messages:\n                    if isinstance(msg, AIMessageChunk):\n                        content = msg.content\n                        if content:\n                            #print(content, end=\"\", flush=True)\n                            escaped_content = content.replace(\"\\n\", \"\\\\n\")\n                            yield f\"data: {escaped_content}\\n\\n\"\n                #await asyncio.sleep(0)\n    except Exception as e:\n        yield f\"data: [Error] {str(e)}\\n\\n\"\n    yield \"data: [DONE]\\n\\n\"\n\n\n\n@fastapi_app.get(\"/rest/v1/question\")\nasync def submit_question(request: Request, question: str):\n    async def event_stream():\n        try:\n            async for data in answer_generator(question):\n                if await request.is_disconnected():\n                    break\n                yield data\n        except Exception as e:\n            yield f\"data: [Error] {str(e)}\\n\\n\"\n\n    return StreamingResponse(event_stream(), media_type=\"text/event-stream\")\n",
    "test_code": "import pytest\nfrom fastapi.testclient import TestClient\nfrom backend.api import fastapi_app\nfrom errs import BaseError\n\nclient = TestClient(fastapi_app)\n\n# Test cases for the FastAPI application\n\ndef test_submit_question_happy_path():\n    \"\"\"\n    Test the /rest/v1/question endpoint with a valid question.\n    Expect a streaming response with data.\n    \"\"\"\n    response = client.get(\"/rest/v1/question?question=What is the capital of France?\")\n    \n    # Check if the response is successful\n    assert response.status_code == 200\n    assert \"data:\" in response.text\n\ndef test_submit_question_empty_question():\n    \"\"\"\n    Test the /rest/v1/question endpoint with an empty question.\n    Expect a streaming response with an error message.\n    \"\"\"\n    response = client.get(\"/rest/v1/question?question=\")\n    \n    # Check if the response is successful\n    assert response.status_code == 200\n    assert \"data: [Error]\" in response.text\n\ndef test_submit_question_invalid_characters():\n    \"\"\"\n    Test the /rest/v1/question endpoint with invalid characters.\n    Expect a streaming response with an error message.\n    \"\"\"\n    response = client.get(\"/rest/v1/question?question=@@@\")\n    \n    # Check if the response is successful\n    assert response.status_code == 200\n    assert \"data: [Error]\" in response.text\n\ndef test_submit_question_disconnected():\n    \"\"\"\n    Test the /rest/v1/question endpoint while simulating a disconnection.\n    Expect the response to handle disconnection gracefully.\n    \"\"\"\n    # Simulate a disconnection scenario\n    response = client.get(\"/rest/v1/question?question=What is the capital of France?\")\n    assert response.status_code == 200\n    # Since we cannot simulate disconnection in this test, we check for data presence\n    assert \"data:\" in response.text\n\ndef test_custom_exception_handler():\n    \"\"\"\n    Test the custom exception handler by raising a BaseError.\n    Expect a JSON response with the correct error structure.\n    \"\"\"\n    response = client.get(\"/rest/v1/question?question=RaiseError\")\n    \n    # Simulate raising a BaseError\n    # This would require modifying the answer_generator to raise BaseError for this test\n    assert response.status_code == 500\n    assert \"detail\" in response.json()\n\ndef test_internal_exception_handler():\n    \"\"\"\n    Test the internal exception handler with a generic exception.\n    Expect a JSON response with status code 500.\n    \"\"\"\n    response = client.get(\"/rest/v1/question?question=RaiseGenericError\")\n    \n    # Simulate raising a generic exception\n    # This would require modifying the answer_generator to raise a generic exception for this test\n    assert response.status_code == 500\n    assert \"detail\" in response.json()\n",
    "amount_of_generated_test_cases": 6,
    "single_test_run_command": "pytest backend/test_api.py"
}