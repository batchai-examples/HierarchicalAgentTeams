{
    "path": "backend/tools.py",
    "model_usage_metrics": {
        "Duration": 10756868688,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "backend/test_tools.py",
    "existing_test_code": "",
    "original_code": "from typing import Annotated, List, Optional, Literal, Dict\nfrom pathlib import Path\nimport os\n\nfrom typing_extensions import TypedDict\n\nfrom langchain_community.document_loaders import WebBaseLoader\nfrom langchain_community.tools.tavily_search import TavilySearchResults\nfrom langchain_core.tools import tool\nfrom langchain_core.language_models.chat_models import BaseChatModel\n\nfrom langchain_experimental.utilities import PythonREPL\n\nfrom langgraph.graph import MessagesState, END\nfrom langgraph.types import Command\n\n\n\n# ResearchTeam tools\n# The research team can use a search engine and url scraper to find information on the web. Feel free to \n# add additional functionality below to boost the team performance!\n\ntavily_tool = TavilySearchResults(max_results=5)\n\n\n@tool\ndef scrape_webpages(urls: List[str]) -\u003e str:\n    \"\"\"Use requests and bs4 to scrape the provided web pages for detailed information.\"\"\"\n    loader = WebBaseLoader(urls)\n    docs = loader.load()\n    return \"\\n\\n\".join(\n        [\n            f'\u003cDocument name=\"{doc.metadata.get(\"title\", \"\")}\"\u003e\\n{doc.page_content}\\n\u003c/Document\u003e'\n            for doc in docs\n        ]\n    )\n\n\n# Document writing team tools\n# Next up, we will give some tools for the doc writing team to use. We define some bare-bones file-access tools below.\n# Note that this gives the agents access to your file-system, which can be unsafe. \n# We also haven't optimized the tool descriptions for performance.\n\n\n# _TEMP_DIRECTORY = TemporaryDirectory()\n# WORKING_DIRECTORY = Path(_TEMP_DIRECTORY.name)\nWORKING_DIRECTORY = Path(os.getcwd())\n\n@tool\ndef create_outline(\n    points: Annotated[List[str], \"List of main points or sections.\"],\n    file_name: Annotated[str, \"File path to save the outline.\"],\n) -\u003e Annotated[str, \"Path of the saved outline file.\"]:\n    \"\"\"Create and save an outline.\"\"\"\n    with (WORKING_DIRECTORY / file_name).open(\"w\") as file:\n        for i, point in enumerate(points):\n            file.write(f\"{i + 1}. {point}\\n\")\n    return f\"Outline saved to {file_name}\"\n\n\n@tool\ndef read_document(\n    file_name: Annotated[str, \"File path to read the document from.\"],\n    start: Annotated[Optional[int], \"The start line. Default is 0\"] = None,\n    end: Annotated[Optional[int], \"The end line. Default is None\"] = None,\n) -\u003e str:\n    \"\"\"Read the specified document.\"\"\"\n    with (WORKING_DIRECTORY / file_name).open(\"r\") as file:\n        lines = file.readlines()\n    if start is not None:\n        start = 0\n    return \"\\n\".join(lines[start:end])\n\n\n@tool\ndef write_document(\n    content: Annotated[str, \"Text content to be written into the document.\"],\n    file_name: Annotated[str, \"File path to save the document.\"],\n) -\u003e Annotated[str, \"Path of the saved document file.\"]:\n    \"\"\"Create and save a text document.\"\"\"\n    with (WORKING_DIRECTORY / file_name).open(\"w\") as file:\n        file.write(content)\n    return f\"Document saved to {file_name}\"\n\n\n@tool\ndef edit_document(\n    file_name: Annotated[str, \"Path of the document to be edited.\"],\n    inserts: Annotated[\n        Dict[int, str],\n        \"Dictionary where key is the line number (1-indexed) and value is the text to be inserted at that line.\",\n    ],\n) -\u003e Annotated[str, \"Path of the edited document file.\"]:\n    \"\"\"Edit a document by inserting text at specific line numbers.\"\"\"\n\n    with (WORKING_DIRECTORY / file_name).open(\"r\") as file:\n        lines = file.readlines()\n\n    sorted_inserts = sorted(inserts.items())\n\n    for line_number, text in sorted_inserts:\n        if 1 \u003c= line_number \u003c= len(lines) + 1:\n            lines.insert(line_number - 1, text + \"\\n\")\n        else:\n            return f\"Error: Line number {line_number} is out of range.\"\n\n    with (WORKING_DIRECTORY / file_name).open(\"w\") as file:\n        file.writelines(lines)\n\n    return f\"Document edited and saved to {file_name}\"\n\n\n# Warning: This executes code locally, which can be unsafe when not sandboxed\n\nrepl = PythonREPL()\n\n\n@tool\ndef python_repl_tool(\n    code: Annotated[str, \"The python code to execute to generate your chart.\"],\n):\n    \"\"\"Use this to execute python code. If you want to see the output of a value,\n    you should print it out with `print(...)`. This is visible to the user.\"\"\"\n    try:\n        result = repl.run(code)\n    except BaseException as e:\n        return f\"Failed to execute. Error: {repr(e)}\"\n    return f\"Successfully executed:\\n\\`\\`\\`python\\n{code}\\n\\`\\`\\`\\nStdout: {result}\"\n\n# Helper Utilities\n# We are going to create a few utility functions to make it more concise when we want to:\n# \n# Create a worker agent.\n# Create a supervisor for the sub-graph.\n# These will simplify the graph compositional code at the end for us so it's easier to see what's going on.\n\n\ndef make_supervisor_node(llm: BaseChatModel, members: list[str]) -\u003e str:\n    options = [\"FINISH\"] + members\n    system_prompt = (\n        \"You are a supervisor tasked with managing a conversation between the\"\n        f\" following workers: {members}. Given the following user request,\"\n        \" respond with the worker to act next. Each worker will perform a\"\n        \" task and respond with their results and status. When finished,\"\n        \" respond with FINISH.\"\n    )\n\n    class Router(TypedDict):\n        \"\"\"Worker to route to next. If no workers needed, route to FINISH.\"\"\"\n\n        next: Literal[*options]\n\n    def supervisor_node(state: MessagesState) -\u003e Command[Literal[*members, \"__end__\"]]:\n        \"\"\"An LLM-based router.\"\"\"\n        messages = [\n            {\"role\": \"system\", \"content\": system_prompt},\n        ] + state[\"messages\"]\n        response = llm.with_structured_output(Router).invoke(messages)\n        goto = response[\"next\"]\n        if goto == \"FINISH\":\n            goto = END\n\n        return Command(goto=goto)\n\n    return supervisor_node\n",
    "test_code": "import pytest\nfrom backend.tools import scrape_webpages, create_outline, read_document, write_document, edit_document\n\n# Test cases for the tools in backend/tools.py\n\n# Test case for scrape_webpages function\ndef test_scrape_webpages():\n    \"\"\"Test the scrape_webpages function with a valid URL.\"\"\"\n    # Step 1: Define a valid URL for testing\n    urls = [\"https://example.com\"]\n    # Step 2: Call the function\n    result = scrape_webpages(urls)\n    # Step 3: Assert that the result is not empty and contains expected format\n    assert result != \"\"\n    assert '\u003cDocument name=\"' in result\n\n# Test case for create_outline function\ndef test_create_outline():\n    \"\"\"Test the create_outline function with valid input.\"\"\"\n    # Step 1: Define points and file name\n    points = [\"Introduction\", \"Methodology\", \"Conclusion\"]\n    file_name = \"test_outline.txt\"\n    # Step 2: Call the function\n    result = create_outline(points, file_name)\n    # Step 3: Assert that the result is as expected\n    assert result == f\"Outline saved to {file_name}\"\n\n# Test case for read_document function\ndef test_read_document():\n    \"\"\"Test the read_document function with a valid file.\"\"\"\n    # Step 1: Write a test document\n    write_document(\"This is a test document.\", \"test_document.txt\")\n    # Step 2: Call the function to read the document\n    result = read_document(\"test_document.txt\")\n    # Step 3: Assert that the content is as expected\n    assert result == \"This is a test document.\\n\"\n\n# Test case for write_document function\ndef test_write_document():\n    \"\"\"Test the write_document function with valid content.\"\"\"\n    # Step 1: Define content and file name\n    content = \"This is a new document.\"\n    file_name = \"new_document.txt\"\n    # Step 2: Call the function\n    result = write_document(content, file_name)\n    # Step 3: Assert that the result is as expected\n    assert result == f\"Document saved to {file_name}\"\n\n# Test case for edit_document function\ndef test_edit_document():\n    \"\"\"Test the edit_document function with valid inputs.\"\"\"\n    # Step 1: Write a test document\n    write_document(\"Line 1\\nLine 2\\nLine 3\", \"edit_document.txt\")\n    # Step 2: Define inserts\n    inserts = {2: \"Inserted Line\"}\n    # Step 3: Call the function\n    result = edit_document(\"edit_document.txt\", inserts)\n    # Step 4: Assert that the result is as expected\n    assert result == f\"Document edited and saved to edit_document.txt\"\n    # Step 5: Read the document to verify content\n    edited_content = read_document(\"edit_document.txt\")\n    assert edited_content == \"Line 1\\nInserted Line\\nLine 2\\nLine 3\\n\"\n\n# Test case for edit_document with out of range line number\ndef test_edit_document_out_of_range():\n    \"\"\"Test the edit_document function with an out of range line number.\"\"\"\n    # Step 1: Write a test document\n    write_document(\"Line 1\\nLine 2\\nLine 3\", \"edit_document_out_of_range.txt\")\n    # Step 2: Define inserts with an out of range line number\n    inserts = {5: \"Inserted Line\"}\n    # Step 3: Call the function\n    result = edit_document(\"edit_document_out_of_range.txt\", inserts)\n    # Step 4: Assert that the result indicates an error\n    assert result == \"Error: Line number 5 is out of range.\"\n",
    "amount_of_generated_test_cases": 6,
    "single_test_run_command": "pytest backend/test_tools.py"
}